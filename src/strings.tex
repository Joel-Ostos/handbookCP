\section{Strings}
\begin{enumerate}
\item Knuth Morris Pratt
Encontrar todas las ocurrencias de un patrón en un texto.
	\begin{lstlisting}[language=C++]
#include <iostream>
#include <vector>
#include <string>

using namespace std;

void computeLPSArray(const string& pat, vector<int>& lps) {
    int length = 0;
    int i = 1;
    lps[0] = 0;

    while (i < pat.size()) {
        if (pat[i] == pat[length]) {
            length++;
            lps[i] = length;
            i++;
        } else {
            if (length != 0) {
                length = lps[length - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
}

void KMPSearch(const string& pat, const string& txt) {
    int M = pat.size();
    int N = txt.size();

    vector<int> lps(M);
    computeLPSArray(pat, lps);

    int i = 0;
    int j = 0;
    while (i < N) {
        if (pat[j] == txt[i]) {
            j++;
            i++;
        }

        if (j == M) {
            cout << "Found pattern at index " << i - j << endl;
            j = lps[j - 1];
        } else if (i < N && pat[j] != txt[i]) {
            if (j != 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
}

int main() {
    string txt = "ABABDABACDABABCABAB";
    string pat = "ABABCABAB";
    KMPSearch(pat, txt);
    return 0;
}

	\end{lstlisting}
	\item Rabin-Karp 
	Algoritmo de búsqueda de patrones que utiliza una función hash para encontrar una subcadena en un texto.
	\begin{lstlisting}[language=C++]
	#include <iostream>
#include <string>

using namespace std;

#define d 256
const int q = 101; // A prime number

void RabinKarpSearch(const string& pat, const string& txt) {
    int M = pat.size();
    int N = txt.size();
    int i, j;
    int p = 0; // Hash value for pattern
    int t = 0; // Hash value for txt
    int h = 1;

    for (i = 0; i < M - 1; i++)
        h = (h * d) % q;

    for (i = 0; i < M; i++) {
        p = (d * p + pat[i]) % q;
        t = (d * t + txt[i]) % q;
    }

    for (i = 0; i <= N - M; i++) {
        if (p == t) {
            for (j = 0; j < M; j++) {
                if (txt[i + j] != pat[j])
                    break;
            }
            if (j == M)
                cout << "Pattern found at index " << i << endl;
        }

        if (i < N - M) {
            t = (d * (t - txt[i] * h) + txt[i + M]) % q;
            if (t < 0)
                t = (t + q);
        }
    }
}

int main() {
    string txt = "GEEKS FOR GEEKS";
    string pat = "GEEK";
    RabinKarpSearch(pat, txt);
    return 0;
}
	\end{lstlisting}
	\item Z Algorithm
	 Encontrar todas las ocurrencias de un patrón en un texto.
	\begin{lstlisting}[language=C++]
	#include <iostream>
#include <vector>
#include <string>

using namespace std;

vector<int> calculateZ(const string& s) {
    int n = s.size();
    vector<int> Z(n);
    int L = 0, R = 0, K;

    for (int i = 1; i < n; ++i) {
        if (i > R) {
            L = R = i;
            while (R < n && s[R] == s[R - L])
                R++;
            Z[i] = R - L;
            R--;
        } else {
            K = i - L;
            if (Z[K] < R - i + 1)
                Z[i] = Z[K];
            else {
                L = i;
                while (R < n && s[R] == s[R - L])
                    R++;
                Z[i] = R - L;
                R--;
            }
        }
    }
    return Z;
}

void ZSearch(const string& text, const string& pattern) {
    string concat = pattern + "$" + text;
    vector<int> Z = calculateZ(concat);

    for (int i = 0; i < Z.size(); ++i) {
        if (Z[i] == pattern.size())
            cout << "Pattern found at index " << i - pattern.size() - 1 << endl;
    }
}

int main() {
    string text = "GEEKS FOR GEEKS";
    string pattern = "GEEK";
    ZSearch(text, pattern);
    return 0;
}
	\end{lstlisting}
	\item Longest Common Subsequence
	Encuentra la subsecuencia común más larga entre dos secuencias.
	\begin{lstlisting}[language=C++]
	#include <iostream>
#include <vector>
#include <string>

using namespace std;

int LCS(const string& X, const string& Y) {
    int m = X.size();
    int n = Y.size();
    vector<vector<int>> L(m + 1, vector<int>(n + 1));

    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= n; j++) {
            if (i == 0 || j == 0)
                L[i][j] = 0;
            else if (X[i - 1] == Y[j - 1])
                L[i][j] = L[i - 1][j - 1] + 1;
            else
                L[i][j] = max(L[i - 1][j], L[i][j - 1]);
        }
    }
    return L[m][n];
}

int main() {
    string X = "AGGTAB";
    string Y = "GXTXAYB";
    cout << "Length of LCS is " << LCS(X, Y) << endl;
    return 0;
}
	\end{lstlisting}
	\item Longest Palindromic Subsequence:
	Encuentra la subcadena palindrómica más larga dentro de una cadena dada
	\begin{lstlisting}[language=C++]
	#include <iostream>
#include <string>

using namespace std;

string longestPalindromicSubstring(const string& s) {
    int n = s.size();
    if (n == 0) return "";

    int start = 0, maxLength = 1;

    vector<vector<bool>> table(n, vector<bool>(n, false));

    for (int i = 0; i < n; ++i)
        table[i][i] = true;

    for (int i = 0; i < n - 1; ++i) {
        if (s[i] == s[i + 1]) {
            table[i][i + 1] = true;
            start = i;
            maxLength = 2;
        }
    }

    for (int k = 3; k <= n; ++k) {
        for (int i = 0; i < n - k + 1; ++i) {
            int j = i + k - 1;

            if (table[i + 1][j - 1] && s[i] == s[j]) {
                table[i][j] = true;

                if (k > maxLength) {
                    start = i;
                    maxLength = k;
                }
            }
        }
    }

    return s.substr(start, maxLength);
}

int main() {
    string s = "babad";
    cout << "Longest Palindromic Substring is " << longestPalindromicSubstring(s) << endl;
    return 0;
}
	\end{lstlisting}

\end{enumerate}
